import imaplib
import email
from email.header import decode_header
from email.mime.text import MIMEText
import smtplib
import time
import re

# Gmail IMAP and SMTP settings
IMAP_SERVER = "imap.gmail.com"
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587

# Gmail login credentials
EMAIL_ADDRESS = "storingen.st.ww@gmail.com"
PASSWORD = "deos jnca uuyr ldly"  # Updated app password

# Recipient email address
RECIPIENT_EMAIL = "erwingroot@gmail.com"  # Set recipient email here

# Time to wait before restarting the loop (in minutes)
WAIT_TIME_MINUTES = 5  # Set the wait time here

# Fetch emails using IMAP
def get_emails(imap_server, email_address, password, folder="INBOX", max_emails=5):
    mail = imaplib.IMAP4_SSL(imap_server)  # Initialize IMAP4_SSL directly
    try:
        mail.login(email_address, password)
        print("Logged in to the email server.")
        mail.select(folder)
        status, messages = mail.search(None, 'UNSEEN')  # Fetch unseen emails
        email_ids = messages[0].split()[:max_emails]
        print(f"Found {len(email_ids)} unseen emails.")

        emails = []
        for email_id in email_ids:
            _, msg = mail.fetch(email_id, "(RFC822)")
            for response_part in msg:
                if isinstance(response_part, tuple):
                    msg = email.message_from_bytes(response_part[1])
                    subject, encoding = decode_header(msg["Subject"])[0]
                    if isinstance(subject, bytes):
                        subject = subject.decode(encoding if encoding else "utf-8")
                    if msg.is_multipart():
                        for part in msg.walk():
                            content_type = part.get_content_type()
                            if content_type == "text/plain":
                                body = part.get_payload(decode=True).decode("utf-8")
                                emails.append({"subject": subject, "body": body, "id": email_id})
                                break
                    else:
                        body = msg.get_payload(decode=True).decode("utf-8")
                        emails.append({"subject": subject, "body": body, "id": email_id})
                    print(f"Email fetched: {subject}")
        return emails, mail
    finally:
        print("Logged out from the email server.")

# Move processed emails to 'All Mail' and remove from Inbox
def move_email_to_all_mail(mail, email_id):
    try:
        # Remove from Inbox by adding the \Archive flag
        mail.store(email_id, '+FLAGS', '\\Seen')  # Mark as read
        mail.store(email_id, '+X-GM-LABELS', '\\All')  # Move to 'All Mail'
        mail.store(email_id, '+FLAGS', '\\Deleted')  # Remove from Inbox
        mail.expunge()  # Permanently remove marked messages
        print(f"Email with ID {email_id.decode()} moved to All Mail.")
    except Exception as e:
        print(f"An error occurred while moving the email: {e}")

# Process email text (extract specific information)
def process_email_text(text):
    print("Processing email text...")

    # Normalize text: replace non-breaking spaces and tabs with normal spaces
    text = text.replace("\xa0", " ").replace("\t", " ")

    # Define the fields and their stopping points
    field_patterns = {
        "Installatienaam": ("Installatienaam", "Onderstationnaam"),
        "Onderstation": ("Onderstationnaam", "Onderstationnummer"),
        "Onderstationnummer": ("Onderstationnummer", "Functie"),
        "Omschrijving": ("Omschrijving", "Flank"),
        "Flank": ("Flank", "Tijdstip"),
        "Tijdstip": ("Tijdstip", "This message was autogenerated")
    }

    extracted_info = []

    for label, (start_keyword, end_keyword) in field_patterns.items():
        # Use regex to extract text between start and end keywords
        pattern = rf"{re.escape(start_keyword)}\s*:\s*(.*?)\s*{re.escape(end_keyword)}"
        match = re.search(pattern, text, re.DOTALL)
        if match:
            extracted_info.append(f"{label}: {match.group(1).strip()}")
        else:
            extracted_info.append(f"{label}: <niet gevonden>")  # Default message if field not found

    return extracted_info

# Send email using SMTP
def send_email(smtp_server, smtp_port, login, password, to_email, subject, body):
    msg = MIMEText(body)
    msg["Subject"] = subject
    msg["From"] = login
    msg["To"] = to_email

    with smtplib.SMTP(smtp_server, smtp_port) as server:
        server.starttls()
        server.login(login, password)
        print(f"Sending email: {subject} to {to_email}.")
        server.sendmail(login, to_email, msg.as_string())
        print("Email sent successfully.")

if __name__ == "__main__":
    while True:
        try:
            # Fetch emails using IMAP
            emails, mail = get_emails(IMAP_SERVER, EMAIL_ADDRESS, PASSWORD, max_emails=3)

            # Process and forward each email
            for email_data in emails:
                subject = f"{email_data['subject']}"
                extracted_data = process_email_text(email_data["body"])

                if all("Niet beschikbaar in bronbericht" in field for field in extracted_data):
                    print("Bronbericht onleesbaar")
                else:
                    body = "\n".join(extracted_data)
                    send_email(
                        smtp_server=SMTP_SERVER,
                        smtp_port=SMTP_PORT,
                        login=EMAIL_ADDRESS,
                        password=PASSWORD,
                        to_email=RECIPIENT_EMAIL,
                        subject=subject,
                        body=body,
                    )

                # Move processed email to 'All Mail' and remove from Inbox
                move_email_to_all_mail(mail, email_data["id"])

            print(f"Emails processed and sent! Waiting for {WAIT_TIME_MINUTES} minutes...")
        except Exception as e:
            print(f"An error occurred: {e}")

        time.sleep(WAIT_TIME_MINUTES * 60)
